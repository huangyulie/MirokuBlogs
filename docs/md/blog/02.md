# 了解V8原理和JIT编译

## 认识V8

Google V8 是开源高性能 JavaScript 和 WebAssembly 引擎，被用于 Chrome 和 Node.js 等。
Chrome的市场占有率高达60%，而Node.js是JS后端编程的事实标准。国内的众多浏览器，其实都是基于Chromium浏览器开发，而Chromium相当于开源版本的Chrome，自然也是基于V8引擎的。神奇的是，就连浏览器界的独树一帜的Microsoft也投靠了Chromium阵营。另外，Electron是基于Node.js与Chromium开发桌面应用，也是基于V8的。

## V8高效的特征

### JIT编译

### 垃圾回收

虽然其他语言或者其他的 JavaScript 引擎实现都有垃圾回收，但是 V8 的垃圾回收借鉴了 Java VM 的精确垃圾回收管理，而其他很多语言的垃圾回收用的是保守垃圾管理

### 内联缓存（Inline Cache）

V8 使用了内联缓存的特性来提高属性的访问效率。如访问 this.prop，没有内联缓存的时候，每次都会对哈希表进行一次寻址，而加入了内联缓存的特性之后，V8 能马上知道这个属性的一个偏移
量，而不用再次计算寻址的偏移量了

### 隐藏类

由于 JavaScript 是一门动态的编程语言，因此哪怕是在 ES6 及以上版本的规范中有了class 的一个定义，开发者也能非常方便地对一个对象添加或者移除一个属性。
隐藏类就是对这样一套对象体系中的一个包装——所有属性一样的对象会被归为同一个隐藏类

## 内部结构

V8是一个非常复杂的项目，使用cloc统计可知，它竟然有超过100万行C++代码。
V8由许多子模块构成，其中这4个模块是最重要的：

- Parser：将 JavaScript 源码转换为 Abstract Syntax Tree (AST)；
- Ignition：解释器，将 AST 转换为 Bytecode，解释并执行 Bytecode；同时收集 TurboFan 优化编译所需的信息，比如函数参数的类型；
- TurboFan：编译器，利用Ignition所收集的类型信息，将Bytecode转换为优化的汇编代码（计算机可识别）；
- Orinoco：垃圾回收，负责将程序不再需要的内存空间回收。

> 什么是 Bytecode
：Bytecode 是介于AST和机器码之间的一种代码。与特定类型的机器码无关，Bytecode 需要通过解释器将其转换为机器码后才能执行。


> 为什么需要 Bytecode
：机器码的效率非常高效，但是需要消耗大量的内存来存放转换后的机器码。为了解决内存占用问题，就引入了 Bytecode，减少内存占用

### 解释器

在 V8 出现之前，所有的 JavaScript 虚拟机所采用的都是解释器来解释执行的方式，这是 JavaScript 执行速度过慢的主要原因之一。

`解释器的工作方式`：
边解释，边执行。 解析器解析代码，生成对应字节码，然后解释器直接解释执行字节码。这样子虽然启动快，但对于循环等会存在解释多次的情况。从而导致运行速度变慢，影响到js的执行效率。

```js
for (let i = 0; i < len; i++) {
  doSomething(i)
}
```

如何看到解释器生成的Bytecode：
Node.js是基于V8引擎实现的，因此node命令提供了很多V8引擎的选项，使用node的--print-bytecode选项，可以打印出Ignition生成的Bytecode。

factorial.js如下，由于V8不会编译没有被调用的函数，因此需要在最后一行调用factorial函数

```js
function factorial(N) {  
  if (N === 1) {  
    return 1;  
  } else {  
   return N * factorial(N - 1);  
  }  
}  
  
factorial(10); 

```

使用node命令(node版本为12.6.0)的--print-bytecode选项，打印出Ignition生成的Bytecode

> node --print-bytecode factorial.js 

然后就可以看到bytecode结果了

### 解释器












 